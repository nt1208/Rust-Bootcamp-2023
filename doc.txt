Quy tắc của ownership là trong một thời điểm thì chỉ có 1 chủ sở hữu dữ liệu
VD:
let x = 5;
let y = x;
let z = x; // không thể thực hiện dòng này vì x đã bị dropped sau dòng thứ 2, nghĩa là lúc đó y 
	   // đang nắm giữ giá trị vùng nhớ của x

Có 2 cách cơ bản để xử lý ownership:
- Sử dụng clone(): nhanh và tiện, tuy nhiên khi sử dụng clone(), compiler sẽ sao chép dữ liệu ra
một vùng nhớ mới, vì vậy sẽ gây tốn bộ nhớ.
VD: 
let x = 5;
let y = x.clone();
let z = x.clone();

- Sử dụng reference (borrowing): sử dụng dấu "&" để tham chiếu tới vùng nhớ cần mượn 
+ Shared reference: Biến borrowing chỉ được phép đọc biến owner mà không có quyền sửa đổi 
VD:
let x = 5;
let y = &x;
let z = &x;
println!("x: {}", x); // có thể thực hiện được vì x không bị drop khi được y và z tham chiếu

+ Mutable reference: Ủy quyền sửa đổi dữ liệu cho biến khác
+ VD:
let mut x = String::from("Hello");
let y = &mut x;
y.push_str("World!");
//x.push_str("x want to change");//không thể thực hiện vì đã ủy quyền sửa đổi cho y
println!("y {}", y); //
println!("x: {}", x);

// Lưu ý: Không thể viết ngược lại là:
// println!("x: {}", x);
// println!("y: {}", y);
// Vì dòng print đầu tiên bản chất là imutable reference, đồng nghĩa với việc là drop đi mutable 
// reference của y, nên dòng print sau sẽ gặp lỗi.

- Loại bỏ ownership trong vòng lặp
VD:

    let check = [1,2,3,4,5,6,7];
    let vec = vec![0,1,2,3,4,5,6];
    for value in vec{
        println!("Value: {}", check[value]);
    }
    
     for value in vec{
        println!("Value: {}", check[value]);
    }
Ở ví dụ trên sẽ bị báo lỗi vì ở for đầu tiên, compiler sẽ sử dụng mặc định into_iter (vec.into_iter), nghĩa là biến value sẽ lấy quyền owner của tất cả các phần tử trong vec, dẫn đến các phần tử trong vec sẽ bị dropped, từ đó làm cho vòng lặp for thứ 2 không còn phần tử nào để duyệt
-----> Sử dụng iter() thay thế cho into_iter()
    let check = [1,2,3,4,5,6,7];
    let vec = vec![0,1,2,3,4,5,6];
    for value in vec.iter(){
        println!("Value: {}", check[*value]);
    }
    
     for value in vec.iter(){
        println!("Value: {}", check[*value]);
    }
Bản chất của iter() là tạo con trỏ duyệt qua từng phần tử của vec, vec sẽ trả về tham chiếu của từng phần tử trong vec và được gán cho value, lúc này value có kiểu dữ liệu là &i32, lưu ý nhớ sử dụng dấu "*" để dereference khi muốn sử dụng để làm index truy xuất phần tử của mảng.

fn exercise4_2(value: u32) -> &'static str {
    let str_value = value.to_string(); // Convert u32 to String
    let static_str = Box::leak(str_value.into_boxed_str()); // Convert String to &'static str
    static_str // Return a reference to the &'static str
}

